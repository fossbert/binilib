#' Quick changes to the plotting environment
#'
#' @param a number of rows (passed to mfrow)
#' @param b number of columns (passed to mfrow)
#' @param brewer_n number of colours to retrieve from RColorBrewer palette
#' @param brewer_name RColorBrewer palette
#' @param ... further arguments passed to par
#' @return By default only a new colour palette
#' @export
mypar <- function(a = 1, b = 1, brewer_n = 9, brewer_name = "Set1", ...) {

    graphics::par(mfrow = c(a, b), ...)
    grDevices::palette(RColorBrewer::brewer.pal(brewer_n, brewer_name))
    tmp <- ggplot2::theme_bw() + ggplot2::theme(axis.text = element_text(colour = 'black', size = 10))
    ggplot2::theme_set(tmp)

}

#' Plot quantiles per column for a numeric matrix
#'
#' @param eset numeric matrix typically containing gene expression data
#' @param quants integer of number of top MR to consider
#' @param brewer_name RColorBrewer palette, defaults to Dark2
#' @param ... further arguments passed to matplot
#' @return graph with the respective quantiles across the sample space
#' @export

kaboxplot <- function(eset,
                      quants = c(0.05, 0.25, 0.5, 0.75, 0.95),
                      brewer_name = 'Dark2',
                      ylab = 'Normalized expression',
                      xlab = 'Samples', ...) {

    nq <- length(quants)
    qs <- t(apply(eset, 2, quantile, probs = quants, na.rm = TRUE))
    info <- colMeans(qs)

    oldmar <- par()$mar
    par(mar = rep(4.1, 4), las = 1)
    matplot(qs,
            type = "l",
            lty = 1,
            col = RColorBrewer::brewer.pal(nq, brewer_name),
            ylab = ylab,
            xlab = xlab,
            ...)
    axis(side = 4, at = info, labels = names(info)) # info on quantiles
    par(mar = oldmar, las = 0)
}


#' Add a custom color gradient to a base R plot
#'
#' @param col a chracter vector as returned from colorRampPalette
#' @param level a factor generated by cutting a continuous variable into many pieces (e.g. 100)
#' @param side where to draw the color gradient, default is 4, i.e. right
#' @return added a color gradient to existing plot
#' @export
legend_col <- function(col, level, side = 4){

    opar <- par

    n <- length(col)

    bx <- par("usr")

    box.cx <- c(bx[2] + (bx[2] - bx[1]) / 1000,
                bx[2] + (bx[2] - bx[1]) / 1000 + (bx[2] - bx[1]) / 50)
    box.cy <- c(bx[3], bx[3])
    box.sy <- (bx[4] - bx[3]) / n

    xx <- rep(box.cx, each = 2)

    par(xpd = TRUE)
    for(i in 1:n){

        yy <- c(box.cy[1] + (box.sy * (i - 1)),
                box.cy[1] + (box.sy * (i)),
                box.cy[1] + (box.sy * (i)),
                box.cy[1] + (box.sy * (i - 1)))
        polygon(xx, yy, col = col[i], border = col[i])

    }
    par(new = TRUE)
    plot(0, 0, type = "n",
         ylim = c(min(level), max(level)),
         yaxt = "n", ylab = "",
         xaxt = "n", xlab = "",
         frame.plot = FALSE)
    axis(side = side, las = 2, tick = FALSE, line = .25)
    par <- opar
}



